# Jenkins installation on a GKE cluster

* Creation and configuration (RBAC) of cluster to allow Jenkins installation
* Helm (Tiller) install to deploy Jenkins on GKE as a chart

The process is performed automatically by running `jenkins-intallation/setup.sh` following the explanations in https://cloud.google.com/solutions/jenkins-on-kubernetes-engine-tutorial. Please, take a look at it for additional comments on the installation process and possible workarounds.

After the correct installation of Jenkins, we can access Jenkins server using port redirection of out pod:
```sh
$ export POD_NAME=$(kubectl get pods -o jsonpath="{.items[0].metadata.name}")
$ kubectl port-forward $POD_NAME 8080:8080 >> /dev/null &
$ printf $(kubectl get secret cd-jenkins -o jsonpath="{.data.jenkins-admin-password}" | base64 --decode);echo
```

The last line prints the autogenerated password generated by the Chart installation needed to login on Jenkins together with 'admin' username.

If we take a look to `kubectl get services -o wide`, two services for Jenkins master are shown, both ClusterIP types, one serving on port 5000 (used by the executors to talk to the master) and 8080 to access to the UI. In this case, as we have redirected our ports, we can access to the UI although it is a private ClusterIP service. This is the default service creation performed by the Jenkins chart we used. If we want our Jenkins master service to be accessed from outside, we can run

```sh
$ kubectl create -f master-ui-service.yaml
```

and use the provided "external-ip" to access Jenkins in `external-ip:8080` as the created service is type LoadBalancer.

# Pushing image to Google Container Registry

We want to show how a Jenkins pipeline is run every time we make a change in app source code and then a new image is built and a new deployment is performed on our cluster containing app last changes. To do so, as we can see in `sample-app/Dockerfile`, a simple nginx Docker image has been taken and html files in app folder will be copied to nginx webapp folder. This way, every time we make a change in index.html, those changes will be exposed through our service.

First of all, we will test our image by building, tagging and pushing it to the GCR:
```sh
# Configure credentials for short-lived access from Docker (for example, pushing an image)
$ gcloud auth configure-docker
$ export GCP_PROJECT=$(gcloud config get-value project)
$ IMAGE_FULLNAME=eu.gcr.io/$GCP_PROJECT/jenkins-sampleapp
$ docker tag jenkins-sampleapp $IMAGE_FULLNAME
$ docker push $IMAGE_FULLNAME
```

We can check that our image is correctly pushed by navigating to Container Registry tab in GCP console.

# Deploying sample application with production, canary and development environments
Now we will deploy our app to our cluster and check it works correctly:
```sh
# As a good practice, a separated logical namespace for our app
$ kubectl create namespace live-app
# We use 2 separated deployments/pods for production and canary environments
$ kubectl --namespace=live-app apply -f k8s-app/sampleapp-production.yaml
$ kubectl --namespace=live-app apply -f k8s-app/sampleapp-canary.yaml
# We can check both pods:
$ kubectl --namespace=live-app get pods
# The LoadBalancer service will choose pods from both environments as they share the label "app: sampleapp"
$ kubectl --namespace=live-app apply -f k8s-app/sampleapp-service.yaml
# We can take the assigned IP for our service
$ export APP_SERVICE_IP=$(kubectl get -o jsonpath="{.status.loadBalancer.ingress[0].ip}"  --namespace=live-app services sampleapp-svc)
# We can see the current source code of sample-app/html/index.html with
$ curl http://$APP_SERVICE_IP
```

# Pushing application code to Cloud Source repository
As an exercise, we are going to upload our source code to a GCP source repository in Cloud Source. It is not essential, as the source for a Jenkins pipeline can be any code repository, for example GitHub.

```sh
$ gcloud source repos create jenkins-sampleapp
$ git init
$ git config credential.helper gcloud.sh
$ export PROJECT_ID=$(gcloud config get-value project)
$ git remote add origin https://source.developers.google.com/p/$PROJECT_ID/r/jenkins-sampleapp
$ git add .
$ git commit -m "App first version"
$ git push origin master
```

# Pipeline creation
Let's access Jenkins via `localhost:8080`, login and follow the steps in https://cloud.google.com/solutions/continuous-delivery-jenkins-kubernetes-engine#Creating%20a%20pipeline to configure our pipeline, by specifying the URL of our code repository in Cloud Source (or any public repo like GitHub). We must define the actions performed for the pipeline in `Jenkinsfile`, so let's take a look at it. 

Firstly we define the agent, Kubernetes, and the pods that will run the Jenkins executors on our cluster, with the needed containers for pipeline stages, in our case `kubectl` and `gcloud`. The second element are the stages in our pipeline. A Docker image must be built from our source code and pushed to GCR, in the first stage. The second stage is deploying that image on our GKE cluster using the same K8S manifests we used for our first deployment to the environments, depending on the changed git branch, master, canary or other development branch. In the case of a development branch, the service yaml definition is modified to avoid the use of a LoadBalancer service, because we don't want that environment to be accessed by app users, as it is not a stable branch.

When we commit any change in our code repo, for example changing the message in index.html, a Jenkins pipeline is automatically started performing the described jobs. After pushing the changes, we can have a look at Jenkins UI and will see the pipeline running. During the process, if we run `$ kubectl --namespace=live-app get pods` we will see a number of new pods automatically deployed to perform those jobs that will be removed when the pipeline is finished. When finished, we can see the new built image (with the correct tag depending on the branch and version number) in our Container Registry. If we access our app via external-ip, we will see the new message in index.html.